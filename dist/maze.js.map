{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/js/Maze.js","src/js/main.js"],"names":[],"mappings":"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","file":"maze.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","const PATH = 0,\n      WALL = 1,\n      VISITED = 2;\n\nmodule.exports = class {\n\n    constructor(element, width, height) {\n        const tiles = (width * 2 + 1) * (height * 2 + 1);\n\n        this.width = width;\n        this.height = height;\n        this.columns = width * 2 + 1;\n        this.rows = height * 2 + 1;\n\n        this.wallSize = Math.ceil(40 / width);\n        this.roomSize = (element.width - ((width + 1) * this.wallSize)) / width;\n\n        this._DIRECTIONS = {\n            left: -1,\n            right: 1,\n            up: -this.columns,\n            down: this.columns\n        };\n        \n        this._element = element;\n        this._canvas = element.getContext('2d');\n\n        this.tiles = new Array(tiles).fill(WALL);\n    }\n\n    drawMaze() {\n        this._canvas.clearRect(0, 0, this._element.width, this._element.height);\n\n        this.tiles.forEach((type, tile) => {\n            let color = ['white', 'black'][type];\n            this.drawTile(tile, color);\n        });\n    }\n\n    drawTile(tile, color) {\n        const col = this.getColumn(tile),\n            row = this.getRow(tile),\n            x = (Math.ceil(col / 2) * this.wallSize) + (Math.ceil(col / 2) - col % 2) * this.roomSize,\n            y = (Math.ceil(row / 2) * this.wallSize) + (Math.ceil(row / 2) - row % 2) * this.roomSize,\n            width  = (col % 2) ? this.roomSize : this.wallSize,\n            height = (row % 2) ? this.roomSize : this.wallSize;\n\n        this._canvas.fillStyle = color;\n        this._canvas.fillRect(x, y, width, height);\n    }\n\n    generatePath(start, end) {\n        // TODO: move to separate file?\n        // TODO: implement variations (depth first, breadth first, stacked, recursive)\n        let direction = this.getAllowedDirections(start, WALL)[0];\n\n        try {\n            this.walk(start, direction);\n        } catch (e) {\n            alert(e + \"\\n\\nTry generating a smaller maze or use the stacked approach (coming soon)\");\n        }\n\n        this.setTile(end, 0);\n    }\n\n    walk(from, direction) {\n        let allowedDirections,\n            lastStep,\n            wall = this.isWall(from) ? from : this.getNextTile(from, direction),\n            room = this.getNextTile(wall, direction);\n\n        this.setTile(wall, PATH);\n        this.setTile(room, PATH);\n\n        /*jshint boss:true */\n        while(allowedDirections = this.getAllowedDirections(room, WALL, 2)) {\n            // TODO: Add option for horizontal/vertical bias\n            let rnd = Math.floor(Math.random() * allowedDirections.length),\n                nextDirection = allowedDirections[rnd];\n\n            lastStep = this.walk(room, nextDirection);\n        }\n\n        return lastStep || room;\n    }\n\n    getAllowedDirections(tile, allowedType, step = 1) {\n        let allowed = Object.keys(this._DIRECTIONS).filter((direction) => {\n\n            let nextRoom = tile;\n\n            for(let i = 0; i < step; i++) {\n                nextRoom = this.getNextTile(nextRoom, direction);\n\n                let type = this.getTileType(nextRoom),\n                    isAllowed = type === allowedType,\n                    isIntersection = this.isIntersection(nextRoom);\n\n                if(!isAllowed || isIntersection) {\n                    return false;\n                }\n            }\n\n            return true;\n        });\n\n        // Return null instead of empty array so we can use the method in a while condition\n        return (allowed.length > 0) ? allowed : null;\n    }\n\n    getColumn(tile) {\n        return Math.floor(tile % this.columns);\n    }\n\n    getNextTile(tile, direction) {\n        let next = tile + this._DIRECTIONS[direction];\n\n        return this.isAdjacent(tile, next) ? next : null;\n    }\n\n    getRow(tile) {\n        return Math.floor((tile) / this.columns);\n    }\n\n    getTileType(tile) {\n        return this.tiles[tile];\n    }\n\n    isAdjacent(tile, next) {\n        return this.getRow(tile) === this.getRow(next) || this.getColumn(tile) === this.getColumn(next);\n    }\n\n    isIntersection(tile) {\n        return this.getRow(tile) % 2 === 0 && this.getColumn(tile) % 2 === 0;\n    }\n\n    isWall(tile) {\n        return this.getRow(tile) % 2 === 0 || this.getColumn(tile) % 2 === 0;\n    }\n\n    setTile(tile, type) {\n        this.tiles[tile] = type;\n    }\n\n    solve(start, end) {\n        const markVisited = tile => {\n            this.setTile(tile, VISITED);\n            this.drawTile(tile, 'red');\n        };\n\n        let current,\n            queue = [start];\n\n        markVisited(start);\n\n        while(current = queue.shift()) {\n            let directions;\n\n            while(directions = this.getAllowedDirections(current, PATH)) {\n\n                directions.forEach((direction) => {\n                    let tile = this.getNextTile(current, direction);\n\n                    markVisited(tile);\n\n                    if(tile === end) {\n                        queue = [];\n                    } else {\n                        queue.push(tile);\n                    }\n                });\n            }\n        }\n    }\n\n\n    _log() {\n        let output = '';\n\n        this.tiles.forEach((tile, i) => {\n            output += tile;\n\n            if((i + 1) % this.columns === 0) {\n                output += '\\n';\n            }\n        });\n\n        console.log(output);\n    }\n}","// TODO: split into modules\n// TODO: MazeGenerator class?\n// TODO: implement options object as argument\n// TODO: implement maze solver\n(function () {\n\n    var Maze = require('./Maze.js'),\n\n    // TODO: put in one SETTINGS object\n        MAZE_ELEMENT = document.getElementById('maze'),\n        START_BUTTON = document.getElementById('start'),\n        SOLVE__BUTTON = document.getElementById('solve'),\n        WIDTH = 50,\n        HEIGHT = 50,\n\n    // TODO: make start tile customizable\n        START = 1,\n    // TODO: let user pick end point after generating\n        END = (WIDTH * 2 + 1) * (HEIGHT * 2 + 1) - 2,\n\n        maze;\n\n    function init() {\n        START_BUTTON.addEventListener('click', start);\n        SOLVE__BUTTON.addEventListener('click', solve);\n    }\n\n    function start() {\n        maze = new Maze(MAZE_ELEMENT, WIDTH, HEIGHT);\n\n        maze.generatePath(START, END);\n        maze.drawMaze();\n\n        SOLVE__BUTTON.removeAttribute('disabled');\n    }\n\n    function solve() {\n        maze.solve(START, END);\n    }\n\n    init();\n}());"]}