{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/js/Maze.js","src/js/main.js"],"names":[],"mappings":"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","file":"maze.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","class Maze {\n\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n\n        this._DIRECTIONS = {\n            left: -1,\n            right: 1,\n            up: -this.columns,\n            down: this.columns\n        };\n\n        this.tiles = new Array((width * 2 + 1) * (height * 2 + 1)).fill(1);\n    }\n\n    draw(element) {\n        if(element.tagName !== 'CANVAS') {\n            throw new Error('Please supply a canvas element to draw on');\n        }\n\n        const canvas = element.getContext('2d'),\n            wallSize = 5,\n            tileSize = (element.width - ((this.width + 1) * wallSize)) / this.width;\n\n        this.tiles.forEach((value, tile) => {\n            const col = this.getColumn(tile),\n                row = this.getRow(tile),\n                x = (Math.floor(col / 2) * wallSize) + (Math.floor(col / 2) + col % 2 - 1) * tileSize,\n                y = (Math.floor(row / 2) * wallSize) + (Math.floor(row / 2) + row % 2 - 1) * tileSize,\n                width = (col % 2) ? wallSize : tileSize,\n                height = (row % 2) ? wallSize : tileSize;\n\n            canvas.fillStyle = ['white', 'black'][value];\n            canvas.fillRect(x, y, width, height);\n        });\n    }\n\n    generatePath(start, direction) {\n        // TODO: move to separate file?\n        // TODO: implement variations (depth first, breadth first, stacked, recursive)\n\n        return this.walk(start);\n    }\n\n    walk(from, direction) {\n        var allowedDirections,\n            lastStep,\n            tile = direction ? this.getNextTile(from, direction) : from;\n\n        // Mark visited\n        this.tiles[tile] = 0;\n\n        /*jshint boss:true */\n        while(allowedDirections = this.getAllowedDirections(tile)) {\n            var rnd = Math.floor(Math.random() * allowedDirections.length),\n                nextDirection = allowedDirections[rnd];\n\n            //maze.removeWall(tile, nextDirection);\n\n            lastStep = this.walk(tile, nextDirection);\n\n            if(this.isWall(lastStep)) {\n                lastStep = this.walk(tile, nextDirection);\n            }\n        }\n\n        return lastStep || tile;\n    }\n\n    // TODO: check next wall and tile at once, only move if both are allowed!\n    getAllowedDirections(tile) {\n        // TODO: move check to getNextTile\n        var onlyAdjacentTiles = (direction) => {\n            var tileNumber = this.getNextTile(tile, direction),\n                sameRow = this.getRow(tileNumber) === this.getRow(tile),\n                sameCol = this.getColumn(tileNumber) === this.getColumn(tile);\n\n            return sameRow || sameCol;\n        };\n\n        var notVisited = (direction) => {\n            var tileNumber = this.getNextTile(tile, direction),\n                nextTile = this.tiles[tileNumber];\n\n            return !!nextTile;\n        };\n\n        var notEdge = (direction) => !this.isEdge(this.getNextTile(tile, direction));\n\n        var allowed = Object.keys(this._DIRECTIONS)\n            .filter(onlyAdjacentTiles)\n            .filter(notEdge)\n            .filter(notVisited);\n\n        // Return null instead of empty array so we can use the method in a while condition\n        return (allowed.length > 0) ? allowed : null;\n    }\n\n    getColumn(tile) {\n        return Math.floor(tile % this.columns) + 1;\n    }\n\n    getNextTile(tile, direction) {\n        return tile + this._DIRECTIONS[direction];\n    }\n\n    // Takes any direction and returns the opposite by performing magic on the array\n    // index. 0 <-> 1, 2 <-> 3, etc.\n    getOppositeDirection(direction) {\n        var directions = Object.keys(this._DIRECTIONS),\n            index = directions.indexOf(direction),\n            opposite = (index % 2) ? -1 : 1;\n\n        return directions[index + opposite];\n    }\n\n    getRow(tile) {\n        return Math.ceil((tile + 1) / this.columns);\n    }\n\n    isEdge(tile) {\n        return this.getColumn(tile) === 1\n            || this.getRow(tile) === 1\n            || this.getColumn(tile) === this.width * 2 + 1\n            || this.getRow(tile) === this.height * 2 + 1\n    }\n\n    isWall(tile) {\n        return this.getRow(tile) % 2 === 0 || this.getColumn(tile) % 2 === 0;\n    }\n\n    removeWall(tile, direction) {\n        var walls = this.tiles[tile].walls,\n            index = walls.indexOf(direction);\n\n        return walls.splice(index, 1);\n    }\n\n    get columns() {\n        return this.width * 2 + 1;\n    }\n}\n\nmodule.exports = Maze;","// TODO: split into modules\n// TODO: MazeGenerator class?\n// TODO: implement options object as argument\n// TODO: implement maze solver\n(function () {\n\n    var Maze = require('./Maze.js'),\n\n        // TODO: put in one SETTINGS object\n        MAZE_ELEMENT = document.getElementById('maze'),\n        START_BUTTON = document.getElementById('start'),\n        WIDTH = 2,\n        HEIGHT = 2,\n\n        START_TILE = 1,\n        START_DIRECTION = 'right',\n\n        maze;\n\n    function init() {\n        START_BUTTON.addEventListener('click', start);\n    }\n\n    function start() {\n        maze = new Maze(WIDTH, HEIGHT);\n\n        let end = maze.generatePath(START_TILE, START_DIRECTION);\n        console.log(end);\n\n        maze.draw(MAZE_ELEMENT);\n    }\n\n    init();\n}());"]}