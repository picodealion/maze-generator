{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/js/main.js"],"names":[],"mappings":"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","file":"maze.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function () {\n\n    var MAZE_ELEMENT = document.getElementById('maze'),\n        START_BUTTON = document.getElementById('start'),\n        WIDTH = 50,\n        HEIGHT = 50,\n\n        DIRECTIONS = {\n            left: -1,\n            right: 1,\n            up: -WIDTH,\n            down: WIDTH\n        },\n        DEFAULT_TILE = {\n            visited: false,\n            walls: ['left', 'right', 'up', 'down']\n        },\n\n        START_TILE = 0,\n        START_DIRECTION = 'right',\n\n        maze = [];\n\n    function init() {\n        START_BUTTON.addEventListener('click', start);\n\n        MAZE_ELEMENT.style.width = WIDTH + 'em';\n        MAZE_ELEMENT.style.height = HEIGHT + 'em';\n    }\n\n    function start() {\n        createMaze();\n\n        var end = walk(START_TILE - 1, START_DIRECTION);\n        console.log(end);\n\n        drawMaze();\n    }\n\n    function createMaze() {\n        for(var i = 0; i < WIDTH * HEIGHT; i++) {\n            maze[i] = JSON.parse(JSON.stringify(DEFAULT_TILE));\n        }\n    }\n\n    function drawMaze() {\n        MAZE_ELEMENT.innerHTML = '';\n\n        maze.forEach(function(tile, index) {\n            var tileElement = document.createElement('div');\n\n            tile.walls.forEach(function (wall) {\n                tileElement.className += ` ${wall}`;\n            });\n\n            tileElement.addEventListener('click', function() {\n                tile.exit = true;\n            });\n\n            MAZE_ELEMENT.appendChild(tileElement);\n        });\n    }\n\n    function walk(from, direction) {\n        var allowedDirections,\n            lastStep,\n            tileNumber = getTileNumber(from, direction);\n\n        removeWall(tileNumber, getOppositeDirection(direction));\n        maze[tileNumber].visited = true;\n\n        /*jshint boss:true */\n        while(allowedDirections = getAllowedDirections(tileNumber)) {\n            var rnd = Math.floor(Math.random() * allowedDirections.length),\n                nextDirection = allowedDirections[rnd];\n\n            removeWall(tileNumber, nextDirection);\n\n            lastStep = walk(tileNumber, nextDirection);\n        }\n\n        return lastStep || tileNumber;\n    }\n\n    function getAllowedDirections(currentTile) {\n        var allowed = Object.keys(DIRECTIONS)\n                        .filter(onlyAdjacentTiles)\n                        .filter(notVisited);\n\n        return (allowed.length > 0) ? allowed : null;\n\n        function onlyAdjacentTiles(direction) {\n            var tileNumber = getTileNumber(currentTile, direction);\n\n            return (getRow(tileNumber) === getRow(currentTile) || getColumn(tileNumber) === getColumn(currentTile));\n        }\n\n        function notVisited(direction) {\n            var tileNumber = getTileNumber(currentTile, direction),\n                tile = maze[tileNumber];\n\n            return tile && !tile.visited;\n        }\n    }\n\n    function getTileNumber(currentTile, direction) {\n        return currentTile + DIRECTIONS[direction];\n    }\n\n    function getRow(tile) {\n        return Math.ceil((tile + 1) / WIDTH);\n    }\n\n    function getColumn(tile) {\n        return Math.floor((tile + 1) % WIDTH);\n    }\n\n    // Takes any direction and returns the opposite by performing magic on the array\n    // index. 0 <-> 1, 2 <-> 3, etc.\n    function getOppositeDirection(direction) {\n        var directions = Object.keys(DIRECTIONS),\n            index = directions.indexOf(direction),\n            rest = index % 2,\n            inverse = index + 1 - (2 * rest);\n\n        return directions[inverse];\n    }\n\n    function removeWall(tile, direction) {\n        var walls = maze[tile].walls,\n            index = walls.indexOf(direction);\n\n        return walls.splice(index, 1);\n    }\n\n    init();\n}());"]}